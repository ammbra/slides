=== String composition

Composing strings in Java is cumbersome:

```java
String property = "last_name";
String value = "Doe";

// concatenation
String query =
	"SELECT * FROM Person p WHERE p."
		+ property + " = '" + value + "'";
// formatting
String query =
	"SELECT * FROM Person p WHERE p.%s = '%s'"
		.formatted(property, value);
```

[step=1]
Comes with free SQL injection! üò≥

=== String interpolation

Why not?

```java
// (fictional syntax!)
String query =
	"SELECT * FROM Person p "
		+ "WHERE p.\{property} = '\{value}'";
```

[step=1]
Also comes with free SQL injection! üò≥

=== String interpolation

SQL injections aren't the only concern.

These also need validation and sanitization:

* HTML/XML
* JSON
* YAML
* ...

All follow format-specific rules.

=== String templating

Enter _String Templates_ (https://openjdk.org/jeps/430[JEP 430]):

```java
String query = STR."""
	SELECT * FROM Person p
	WHERE p.\{property} = '\{value}'
	""";
```

_Template expression_ ingredients:

* _template_ with embedded expressions +
  ~> `StringTemplate`
* _template processor_ (e.g. `STR`): +
  transforms `StringTemplate` into `String`*

=== Template procesor STR

```java
String form = STR."""
	Desc     Unit   Qty   Amount
	\{desc} $\{price} \{qty} $\{price * qty}

	Subtotal  $\{price * qty}
	Tax       $\{price * qty * tax}
	Total     $\{price * qty * (1.0 + tax)}
	""";
```
```
Desc     Unit   Qty   Amount
hammer   $7.88  3     $23.64

Subtotal  $23.64
Tax       $3.546
Total     $27.186
```

=== Template processor FMT

```java
String form = FMT."""
	Desc        Unit      Qty   Amount
	%-10s\{desc} $%5.2f\{price} %5d\{qty} $%5.2f\{price * qty}

	Subtotal  $%5.2f\{price * qty}
	Tax       $%5.2f\{price * qty * tax}
	Total     $%5.2f\{price * qty * (1.0 + tax)}
	""";
```
```
Desc        Unit      Qty   Amount
hammer      $ 7.88      3   $23.64

Subtotal  $23.64
Tax       $ 3.55
Total     $27.19
```

=== Why strings?

Often, strings are just exchange format, e.g.:

* _start with_: `String` + values
* _validate / sanitize to_: `String`
* _parse to_: `Statement`, `JSONObject`, ...

Why the detour?

=== Custom templating

Top interface:

```java
public interface ValidatingProcessor<RESULT, EX> {
	RESULT process(StringTemplate s) throws EX;
}
```

`RESULT` can be of any type!

Specializations:

```java
public interface TemplateProcessor<RESULT>
	extends ValidatingProcessor<RESULT, RuntimeException> { }

public interface StringProcessor
	extends TemplateProcessor<String> { }
```

=== Custom templating

```java
// might throw `SQLException`
Statement query = SQL."""
	SELECT * FROM Person p
	WHERE p.\{property} = '\{value}'
	""";

JSONObject doc = JSON."""
	{
		"name":    "\{name}",
		"phone":   "\{phone}",
		"address": "\{address}"
	};
	""";
```

=== Template strings

* https://openjdk.org/jeps/430[JEP 430]
* candidate for JDK 21 üôåüèæ

=== Amber endeavors

Pattern matching:

* pattern matching in `switch` (https://openjdk.org/jeps/433[JEP 433] - in JDK 20)
* record patterns (https://openjdk.org/jeps/432[JEP 432] - in JDK 20)
* primitive types in patterns (https://bugs.openjdk.org/browse/JDK-8288476[JEP draft])
* unnamed patterns/variables (https://bugs.openjdk.org/browse/JDK-8294349[JEP draft])

=== Amber endeavors

Other endeavors and conversations:

* simplified `main` (https://openjdk.org/projects/amber/design-notes/on-ramp[design notes])
* relaxed `super()` (https://mail.openjdk.org/pipermail/amber-dev/2022-October/007537.html[discussions])
* concise method bodies (https://openjdk.java.net/jeps/8209434[JEP draft])
* serialization revamp (https://openjdk.org/projects/amber/design-notes/towards-better-serialization[design notes])
